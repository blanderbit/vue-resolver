{"version":3,"file":"index.js","sources":["../../src/vue-resolver.js"],"sourcesContent":["\n/**\n *\n *  METHOD_HOOK_ENUM\n *\n *  definition - constant for specifying standard resolver methods\n *\n *  usage - for registering a method in the resolver and for calling functions\n *\n *  @const {{\n *      RESOLVER_FIRST_WORKER: string,\n *      RESOLVER_SECOND_WORKER: string,\n *      RESOLVER_FIRST_WORKER_ERROR: string,\n *      AFTER_INTERCEPT: string,\n *      BEFORE_INTERCEPT: string,\n *      RESOLVER_SECOND_WORKER_ERROR: string\n *  }}\n *\n */\n\nconst METHOD_HOOK_ENUM = {\n    BEFORE_INTERCEPT : '_beforeIntercept',\n    AFTER_INTERCEPT : '_afterIntercept',\n    RESOLVER_FIRST_WORKER: '_resolverFirstWorker',\n    RESOLVER_SECOND_WORKER: '_resolverSecondWorker',\n    RESOLVER_FIRST_WORKER_ERROR: '_resolverFirstWorkerError',\n    RESOLVER_SECOND_WORKER_ERROR: '_resolverSecondWorkerError',\n};\n\n/**\n *\n *  @const {{\n *      OBJECT: string,\n *      FUNCTION: string,\n *      BOOLEAN: string\n *  }}\n *\n */\n\nconst JS_TYPES_ENUM = {\n    OBJECT: 'object',\n    FUNCTION: 'function',\n    BOOLEAN: \"boolean\"\n};\n\n/**\n *\n *  checkIfExistType\n *\n *  definition - the checked parameter, exception and type are accepted,\n *               if the checked parameters do not match the type, then\n *               the exception will work\n *\n *  usage - used by 2 functions isObject and isFunction\n *\n *  @example\n *\n *  checkIfExistType(1, '2', 'string')\n *  // returns '2'\n *\n *  @example\n *\n *  checkIfExistType(1, 2, 'number')\n *  // returns 1\n *\n *  @template varA\n *  @template varB\n *\n *  @param { * } varA - can be any kind of data that will be checked\n *                      for the type passed by the \"type\" parameter\n *  @param { * } varB - can be any kind of data that will return as exception\n *  @param { string } type\n *  @return {(varA | varB)}\n */\n\nconst checkIfExistType = (varA, varB, type) => typeof varA === type\n    ? varA\n    : varB;\n\n/**\n *  isObject\n *\n *  definition - works exactly like checkIfExistType only more\n *               specifically for checking for type \"object\",\n *               will check the first parameter for an object and\n *               return it if it is an object or return an exception\n *\n *  usage - used to check for an object, in the default\n *          function to generate parallel requests and custom function\n *\n *  @example\n *\n *\n *\n *  @template varA\n *  @template varB\n *\n *  @param { * } varA - can be any kind of data that will be checked\n *                      for the type passed by the type\n *  @param { * } varB - can be any kind of data that will return as exception\n *  @return {(varA | varB)}\n */\n\nconst isObject = (varA, varB) => checkIfExistType(\n    varA,\n    varB,\n    JS_TYPES_ENUM.OBJECT\n);\n\n/**\n *  isFunction\n *\n *  definition - works exactly like checkIfExistType only more\n *               specifically for checking for type \"function\"\n *\n *  usage - used to check that the input parameter is a function,\n *          since the corresponding call is made after that;\n *          that is, this was done so that if a custom parameter\n *          is passed, then it will work or the default implementation\n *\n *  @example\n *\n *  isFunction(\n *      () => {},\n *      () => Promise.resolve(),\n *  )()\n *\n *  // returns first param () => {}\n *\n *  @template varA\n *  @template varB\n *\n *  @param { * } varA - can be any kind of data that will be checked\n *                      for the type passed by the type\n *  @param { * } varB - can be any kind of data that will return as exception\n *  @return {(varA | varB)}\n */\n\nconst isFunction = (varA, varB) => checkIfExistType(\n    varA,\n    varB,\n    JS_TYPES_ENUM.FUNCTION\n);\n\n/**\n *  VueResolver\n *\n *  definition - creates methods, hooks, properties designed to control the\n *               intermediate moment of transition through routing vue.js\n *\n *  usage - used only in vue.js, namely in the beforeEnter router hook\n *\n */\n\nexport class VueResolver {\n\n    /**\n     *\n     *  _defFunction\n     *\n     *  definition - is intended to set the default value\n     *               of the method to be registered\n     *\n     *  usage - used in places where it will call a synchronous call\n     *\n     *  @template ret\n     *\n     *  @param ret\n     *  @return {(ret | {})}\n     *  @private\n     */\n\n    _defFunction = (ret) => ret ? ret :{};\n\n    /**\n     *\n     *  _defFunctionPromise\n     *\n     *  definition - is intended to set the default value of\n     *               the method to be registered\n     *\n     *  usage - used in places where it will async call\n     *\n     *  @return {Promise<boolean>}\n     *  @private\n     */\n\n    _defFunctionPromise = () => Promise.resolve(true);\n\n    /**\n     *\n     *  _beforeIntercept\n     *\n     *  definition - the hook is launched at the very\n     *               beginning of resolver processing\n     *\n     *  usage - usually used to launch a spinner\n     *\n     *  @type {function(*): {}}\n     *  @private\n     */\n\n    _beforeIntercept = this._defFunction;\n\n    /**\n     *\n     *  _afterIntercept\n     *\n     *  definition - the hook starts at the very end of the resolver\n     *\n     *  usage - usually used to hide a spinner\n     *\n     *  @type {function(*): {}}\n     *  @private\n     */\n\n    _afterIntercept = this._defFunction;\n\n    /**\n     *\n     *  _resolverFirstWorker\n     *\n     *  definition - hook is used to make the 1st level of\n     *               verification before the transition stage\n     *\n     *  usage - used mainly to get a user and check for login,\n     *          but if this system is not needed then it is disabled by default\n     *\n     *  @type {function(): Promise<boolean>}\n     *  @private\n     */\n\n    _resolverFirstWorker = this._defFunctionPromise;\n\n    /**\n     *\n     * _resolverSecondWorker\n     *\n     *  definition - hook is used to make the 2nd level of data retrieval,\n     *               by default the standard function for parallel data retrieval is used\n     *\n     *  usage - used to receive data in parallel,\n     *          requests are defined in the callback itself\n     *\n     *  @type {function(*=)}\n     *  @private\n     */\n\n    _resolverSecondWorker = this._defaultSecondWorker;\n\n    /**\n     *\n     * _resolverFirstWorkerError\n     *\n     *  definition - an error handler if we got false during the first step of the check\n     *\n     *  usage - used as a rule to check that the user is logged\n     *          in or not, if not, then you can take the appropriate action\n     *\n     * @type {function(*): {}}\n     * @private\n     */\n\n    _resolverFirstWorkerError = this._defFunction;\n\n    /**\n     *\n     *  _resolverFirstWorkerError\n     *\n     *  definition - error handler when receiving data\n     *\n     *  usage - used as a rule to check that there is some problem in receiving data\n     *\n     * @type {function(*): {}}\n     * @private\n     */\n\n    _resolverSecondWorkerError = this._defFunction;\n\n    /**\n     *  This callback type is called `requestCallback` and is displayed as a global symbol.\n     *\n     *  @callback resolverCallback\n     *  @param { object } to - object for \"to\" route\n     *  @param { object } from - object for \"from\" route\n     *\n     *  @return { Object } object of functions method which return promise\n     */\n\n    /**\n     *\n     *  routeInterceptor\n     *\n     *  definition - function handler, with the implementation of\n     *               the hooks of the interceptor's life, is made to intercept the moment\n     *               of transition on the page, with the possibility of receiving data\n     *               and flexible management of the authorization system\n     *\n     *  usage - used as a rule in cases of receiving data\n     *          before going to the page, all data is\n     *          requested in parallel, combining such images\n     *\n     *          loader. displaying errors,\n     *          receiving data, checking for a logged in user\n     *\n     *  @param resolverCallback { function }\n     *  @param customFunctions {{\n     *      resolverSecondWorker: undefined | function,\n     *      resolveFirstWorkerError: undefined | function,\n     *      beforeIntercept: undefined | function,\n     *      afterIntercept: undefined | function,\n     *      resolveSecondWorkerError: undefined | function\n     *  }} check resolver methods, its the same but for custom usage, not for global\n     *\n     *  @return { Function | Promise }\n     */\n\n    routeInterceptor(\n        resolverCallback,\n        customFunctions\n    ) {\n\n        customFunctions = isObject(\n            customFunctions,\n            {}\n        );\n\n        const {\n            resolverSecondWorker,\n            resolveFirstWorkerError,\n            beforeIntercept,\n            afterIntercept,\n            resolveSecondWorkerError\n        } = customFunctions;\n\n        return async (to, from, next) => {\n\n            const standardDataParams = {\n                to,\n                from\n            };\n\n            const standardDataParamsWithNext = {\n                ...standardDataParams,\n                next\n            };\n\n            isFunction(\n                beforeIntercept,\n                this[METHOD_HOOK_ENUM.BEFORE_INTERCEPT]\n            )(standardDataParams);\n\n            const resultAsyncCheck = await this[\n                METHOD_HOOK_ENUM.RESOLVER_FIRST_WORKER\n            ](standardDataParamsWithNext);\n\n            if (typeof resultAsyncCheck !== JS_TYPES_ENUM.BOOLEAN || !resultAsyncCheck) {\n                const firstWorkerError = {\n                    ...standardDataParamsWithNext,\n                    error: 'FIRST_WORKER_ERROR'\n                };\n\n                isFunction(\n                    resolveFirstWorkerError,\n                    this[METHOD_HOOK_ENUM.RESOLVER_FIRST_WORKER_ERROR]\n                )(firstWorkerError);\n\n                return next(false)\n            }\n\n            if (typeof resolverCallback === JS_TYPES_ENUM.FUNCTION) {\n                try {\n                    let objRequests = resolverCallback(to, from);\n\n\n                    objRequests = isObject(\n                        objRequests,\n                        {}\n                    );\n\n                    const result = await (\n                        isFunction(\n                            resolverSecondWorker,\n                            this[METHOD_HOOK_ENUM.RESOLVER_SECOND_WORKER]\n                        )(objRequests)\n                    );\n\n                    Object\n                        .keys(result)\n                        .forEach((item) => to.meta[ item ] = result[ item ]);\n\n                } catch ( error ) {\n\n                    const paramsWithError = {\n                        ...standardDataParams,\n                        error\n                    };\n\n                    isFunction(\n                        resolveSecondWorkerError,\n                        this[METHOD_HOOK_ENUM.RESOLVER_SECOND_WORKER_ERROR]\n                    )(paramsWithError);\n\n                    return next(false);\n                }\n            }\n\n            isFunction(\n                afterIntercept,\n                this[METHOD_HOOK_ENUM.AFTER_INTERCEPT]\n            )(standardDataParamsWithNext);\n\n            return next(true);\n        }\n    }\n\n    /**\n     *  _defaultSecondWorker\n     *\n     *  definition - and gets a function object, where each\n     *               function returns a promise, done in order to\n     *               make parallel requests and return a response object\n     *\n     *  usage - check definition\n     *\n     *  @param objRequests\n     *  @return {Promise<void>}\n     *  @private\n     */\n\n    async _defaultSecondWorker (objRequests) {\n        const objData = {};\n        const arrayRequests = Object\n            .keys(objRequests)\n            .map((key, index) => {\n                objData[ index ] = key;\n                return typeof objRequests[ key ] === JS_TYPES_ENUM.FUNCTION\n                    ? objRequests[ key ]()\n                    : Promise.resolve(null);\n            });\n\n        let result = [];\n\n        result = await Promise.all(arrayRequests);\n\n        Object\n            .keys(objData)\n            .forEach(i => {\n                objData[ objData[ i ] ] = result[ i ];\n                delete objData[ i ];\n            });\n\n        return objData;\n    }\n\n    /**\n     *\n     *  registerBeforeIntercept\n     *\n     *  definition - function registration\n     *\n     *  @param fn\n     *  @return {*}\n     */\n\n    registerBeforeIntercept(fn) {\n        return this.registerMethod(\n            METHOD_HOOK_ENUM.BEFORE_INTERCEPT,\n            fn\n        );\n    }\n\n    /**\n     *  registerAfterIntercept\n     *\n     *  definition - function registration\n     *\n     *  @param fn\n     *  @return {*}\n     */\n\n    registerAfterIntercept(fn) {\n        return this.registerMethod(\n            METHOD_HOOK_ENUM.AFTER_INTERCEPT,\n            fn\n        );\n    }\n\n    /**\n     *\n     *  registerResolverFirstWorker\n     *\n     *  definition - function registration\n     *\n     *  @param fn\n     *  @return {*}\n     */\n\n    registerResolverFirstWorker(fn) {\n        return this.registerMethod(\n            METHOD_HOOK_ENUM.RESOLVER_FIRST_WORKER,\n            fn\n        );\n    }\n\n    /**\n     *\n     *  registerResolverSecondWorker\n     *\n     *  definition - function registration\n     *\n     *  @param fn\n     *  @return {*}\n     */\n\n    registerResolverSecondWorker(fn) {\n        return this.registerMethod(\n            METHOD_HOOK_ENUM.RESOLVER_SECOND_WORKER,\n            fn\n        );\n    }\n\n\n    /**\n     *\n     *  registerResolverFirstWorkerError\n     *\n     *  definition - function registration\n     *\n     *  @param fn\n     *  @return {*}\n     */\n\n    registerResolverFirstWorkerError(fn) {\n        return this.registerMethod(\n            METHOD_HOOK_ENUM.RESOLVER_FIRST_WORKER_ERROR,\n            fn\n        );\n    }\n\n\n    /**\n     *\n     *  registerResolverSecondWorkerError\n     *\n     *  definition - function registration\n     *\n     *  @param fn\n     *  @return {*}\n     */\n\n    registerResolverSecondWorkerError(fn) {\n        return this.registerMethod(\n            METHOD_HOOK_ENUM.RESOLVER_SECOND_WORKER_ERROR,\n            fn\n        );\n    }\n\n    /**\n     *  registerMethod\n     *\n     *  definition - reusable function, which takes the name of\n     *               the method and the callback, thereby reassigning\n     *               the default execution\n     *\n     *  usage - used to register different methods\n     *\n     *  @param name\n     *  @param callBack\n     *  @return {VueResolver}\n     */\n\n    registerMethod(name, callBack) {\n        if (typeof callBack !== JS_TYPES_ENUM.FUNCTION || !name) {\n            return this;\n        }\n\n        this[name] = callBack;\n\n        return this;\n    }\n}\n"],"names":["METHOD_HOOK_ENUM","JS_TYPES_ENUM","checkIfExistType","varA","varB","type","_typeof","isObject","isFunction","VueResolver","ret","Promise","resolve","this","_defFunction","_defFunctionPromise","_defaultSecondWorker","resolverCallback","customFunctions","resolverSecondWorker","resolveFirstWorkerError","beforeIntercept","afterIntercept","resolveSecondWorkerError","to","from","next","standardDataParamsWithNext","standardDataParams","_this","resultAsyncCheck","firstWorkerError","error","objRequests","result","Object","keys","forEach","item","meta","paramsWithError","objData","arrayRequests","map","key","index","all","i","fn","registerMethod","name","callBack"],"mappings":"+3CAoBA,IAAMA,EACiB,mBADjBA,EAEgB,kBAFhBA,EAGqB,uBAHrBA,EAIsB,wBAJtBA,EAK2B,4BAL3BA,EAM4B,6BAa5BC,EACM,SADNA,EAEQ,WAFRA,EAGO,UAiCPC,EAAmB,SAACC,EAAMC,EAAMC,UAASC,EAAOH,KAASE,EACzDF,EACAC,GA0BAG,EAAW,SAACJ,EAAMC,UAASF,EAC7BC,EACAC,EACAH,IAgCEO,EAAa,SAACL,EAAMC,UAASF,EAC/BC,EACAC,EACAH,IAaSQ,uJAkBM,SAACC,UAAQA,GAAW,oCAeb,kBAAMC,QAAQC,SAAQ,gCAezBC,KAAKC,uCAcND,KAAKC,4CAgBAD,KAAKE,oDAgBJF,KAAKG,yDAeDH,KAAKC,kDAcJD,KAAKC,+EAyC9BG,EACAC,gBAGAA,EAAkBX,EACdW,EACA,IAIAC,IAAAA,qBACAC,IAAAA,wBACAC,IAAAA,gBACAC,IAAAA,eACAC,IAAAA,4EAGG,WAAOC,EAAIC,EAAMC,4GAOdC,SALAC,EAAqB,CACvBJ,GAAAA,EACAC,KAAAA,QAKAC,KAAAA,IAGJlB,EACIa,EACAQ,EAAK7B,GAFTQ,CAGEoB,YAE6BC,EAC3B7B,GACF2B,aAEErB,EAJEwB,YAI0B7B,GAA0B6B,0BAChDC,SACCJ,OACHK,MAAO,uBAGXxB,EACIY,EACAS,EAAK7B,GAFTQ,CAGEuB,qBAEKL,GAAK,eAGZpB,EAAOW,KAAqBhB,oCAEpBgC,EAAchB,EAAiBO,EAAIC,GAGvCQ,EAAc1B,EACV0B,EACA,cAIAzB,EACIW,EACAU,EAAK7B,GAFTQ,CAGEyB,WAJAC,SAONC,OACKC,KAAKF,GACLG,SAAQ,SAACC,UAASd,EAAGe,KAAMD,GAASJ,EAAQI,gEAI3CE,SACCZ,OACHI,aAGJxB,EACIe,EACAM,EAAK7B,GAFTQ,CAGEgC,qBAEKd,GAAK,mBAIpBlB,EACIc,EACAO,EAAK7B,GAFTQ,CAGEmB,qBAEKD,GAAK,2LAkBpB,WAA4BO,oGAClBQ,EAAU,GACVC,EAAgBP,OACjBC,KAAKH,GACLU,KAAI,SAACC,EAAKC,UACPJ,EAASI,GAAUD,EACZtC,EAAO2B,EAAaW,MAAU3C,EAC/BgC,EAAaW,KACbjC,QAAQC,QAAQ,SAG1BsB,EAAS,YAEEvB,QAAQmC,IAAIJ,iBAA3BR,SAEAC,OACKC,KAAKK,GACLJ,SAAQ,SAAAU,GACLN,EAASA,EAASM,IAAQb,EAAQa,UAC3BN,EAASM,wBAGjBN,iIAaX,SAAwBO,UACbnC,KAAKoC,eACRjD,EACAgD,yCAaR,SAAuBA,UACZnC,KAAKoC,eACRjD,EACAgD,8CAcR,SAA4BA,UACjBnC,KAAKoC,eACRjD,EACAgD,+CAcR,SAA6BA,UAClBnC,KAAKoC,eACRjD,EACAgD,mDAeR,SAAiCA,UACtBnC,KAAKoC,eACRjD,EACAgD,oDAeR,SAAkCA,UACvBnC,KAAKoC,eACRjD,EACAgD,iCAkBR,SAAeE,EAAMC,UACb7C,EAAO6C,KAAalD,GAA2BiD,QAI9CA,GAAQC,EAENtC,MALIA"}