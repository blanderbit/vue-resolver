{"version":3,"file":"index.js","sources":["../../src/vue-resolver.js"],"sourcesContent":["\n/**\n *\n *  METHOD_HOOK_ENUM\n *\n *  definition - constant for specifying standard resolver methods\n *\n *  usage - for registering a method in the resolver and for calling functions\n *\n *  @const {{\n *      RESOLVER_FIRST_WORKER: string,\n *      RESOLVER_SECOND_WORKER: string,\n *      RESOLVER_FIRST_WORKER_ERROR: string,\n *      AFTER_INTERCEPT: string,\n *      BEFORE_INTERCEPT: string,\n *      RESOLVER_SECOND_WORKER_ERROR: string\n *  }}\n *\n */\n\nconst METHOD_HOOK_ENUM = {\n    BEFORE_INTERCEPT : '_beforeIntercept',\n    AFTER_INTERCEPT : '_afterIntercept',\n    RESOLVER_FIRST_WORKER: '_resolverFirstWorker',\n    RESOLVER_SECOND_WORKER: '_resolverSecondWorker',\n    RESOLVER_FIRST_WORKER_ERROR: '_resolverFirstWorkerError',\n    RESOLVER_SECOND_WORKER_ERROR: '_resolverSecondWorkerError',\n};\n\n/**\n *\n *  @const {{\n *      OBJECT: string,\n *      FUNCTION: string,\n *      BOOLEAN: string\n *  }}\n *\n */\n\nconst JS_TYPES_ENUM = {\n    OBJECT: 'object',\n    FUNCTION: 'function',\n    BOOLEAN: \"boolean\"\n};\n\n/**\n *\n *  checkIfExistType\n *\n *  definition - the checked parameter, exception and type are accepted,\n *               if the checked parameters do not match the type, then\n *               the exception will work\n *\n *  usage - used by 2 functions isObject and isFunction\n *\n *  @example\n *\n *  checkIfExistType(1, '2', 'string')\n *  // returns '2'\n *\n *  @example\n *\n *  checkIfExistType(1, 2, 'number')\n *  // returns 1\n *\n *  @template varA\n *  @template varB\n *\n *  @param { * } varA - can be any kind of data that will be checked\n *                      for the type passed by the \"type\" parameter\n *  @param { * } varB - can be any kind of data that will return as exception\n *  @param { string } type\n *  @return {(varA | varB)}\n */\n\nconst checkIfExistType = (varA, varB, type) => typeof varA === type\n    ? varA\n    : varB;\n\n/**\n *  isObject\n *\n *  definition - works exactly like checkIfExistType only more\n *               specifically for checking for type \"object\",\n *               will check the first parameter for an object and\n *               return it if it is an object or return an exception\n *\n *  usage - used to check for an object, in the default\n *          function to generate parallel requests and custom function\n *\n *  @example\n *\n *\n *\n *  @template varA\n *  @template varB\n *\n *  @param { * } varA - can be any kind of data that will be checked\n *                      for the type passed by the type\n *  @param { * } varB - can be any kind of data that will return as exception\n *  @return {(varA | varB)}\n */\n\nconst isObject = (varA, varB) => checkIfExistType(\n    varA,\n    varB,\n    JS_TYPES_ENUM.OBJECT\n);\n\n/**\n *  isFunction\n *\n *  definition - works exactly like checkIfExistType only more\n *               specifically for checking for type \"function\"\n *\n *  usage - used to check that the input parameter is a function,\n *          since the corresponding call is made after that;\n *          that is, this was done so that if a custom parameter\n *          is passed, then it will work or the default implementation\n *\n *  @example\n *\n *  isFunction(\n *      () => {},\n *      () => Promise.resolve(),\n *  )()\n *\n *  // returns first param () => {}\n *\n *  @template varA\n *  @template varB\n *\n *  @param { * } varA - can be any kind of data that will be checked\n *                      for the type passed by the type\n *  @param { * } varB - can be any kind of data that will return as exception\n *  @return {(varA | varB)}\n */\n\nconst isFunction = (varA, varB) => checkIfExistType(\n    varA,\n    varB,\n    JS_TYPES_ENUM.FUNCTION\n);\n\n/**\n *  VueResolver\n *\n *  definition - creates methods, hooks, properties designed to control the\n *               intermediate moment of transition through routing vue.js\n *\n *  usage - used only in vue.js, namely in the beforeEnter router hook\n *\n */\n\nexport class VueResolver {\n\n    /**\n     *\n     *  _defFunction\n     *\n     *  definition - is intended to set the default value\n     *               of the method to be registered\n     *\n     *  usage - used in places where it will call a synchronous call\n     *\n     *  @template ret\n     *\n     *  @param ret\n     *  @return {(ret | {})}\n     *  @private\n     */\n\n    _defFunction = (ret) => ret ? ret :{};\n\n    /**\n     *\n     *  _defFunctionPromise\n     *\n     *  definition - is intended to set the default value of\n     *               the method to be registered\n     *\n     *  usage - used in places where it will async call\n     *\n     *  @return {Promise<boolean>}\n     *  @private\n     */\n\n    _defFunctionPromise = () => Promise.resolve(true);\n\n    /**\n     *\n     *  _beforeIntercept\n     *\n     *  definition - the hook is launched at the very\n     *               beginning of resolver processing\n     *\n     *  usage - usually used to launch a spinner\n     *\n     *  @type {function(*): {}}\n     *  @private\n     */\n\n    _beforeIntercept = this._defFunction;\n\n    /**\n     *\n     *  _afterIntercept\n     *\n     *  definition - the hook starts at the very end of the resolver\n     *\n     *  usage - usually used to hide a spinner\n     *\n     *  @type {function(*): {}}\n     *  @private\n     */\n\n    _afterIntercept = this._defFunction;\n\n    /**\n     *\n     *  _resolverFirstWorker\n     *\n     *  definition - hook is used to make the 1st level of\n     *               verification before the transition stage\n     *\n     *  usage - used mainly to get a user and check for login,\n     *          but if this system is not needed then it is disabled by default\n     *\n     *  @type {function(): Promise<boolean>}\n     *  @private\n     */\n\n    _resolverFirstWorker = this._defFunctionPromise;\n\n    /**\n     *\n     * _resolverSecondWorker\n     *\n     *  definition - hook is used to make the 2nd level of data retrieval,\n     *               by default the standard function for parallel data retrieval is used\n     *\n     *  usage - used to receive data in parallel,\n     *          requests are defined in the callback itself\n     *\n     *  @type {function(*=)}\n     *  @private\n     */\n\n    _resolverSecondWorker = this._defaultSecondWorker;\n\n    /**\n     *\n     * _resolverFirstWorkerError\n     *\n     *  definition - an error handler if we got false during the first step of the check\n     *\n     *  usage - used as a rule to check that the user is logged\n     *          in or not, if not, then you can take the appropriate action\n     *\n     * @type {function(*): {}}\n     * @private\n     */\n\n    _resolverFirstWorkerError = this._defFunction;\n\n    /**\n     *\n     *  _resolverFirstWorkerError\n     *\n     *  definition - error handler when receiving data\n     *\n     *  usage - used as a rule to check that there is some problem in receiving data\n     *\n     * @type {function(*): {}}\n     * @private\n     */\n\n    _resolverSecondWorkerError = this._defFunction;\n\n    /**\n     *  This callback type is called `requestCallback` and is displayed as a global symbol.\n     *\n     *  @callback resolverCallback\n     *  @param { object } to - object for \"to\" route\n     *  @param { object } from - object for \"from\" route\n     *\n     *  @return { Object } object of functions method which return promise\n     */\n\n    /**\n     *\n     *  routeInterceptor\n     *\n     *  definition - function handler, with the implementation of\n     *               the hooks of the interceptor's life, is made to intercept the moment\n     *               of transition on the page, with the possibility of receiving data\n     *               and flexible management of the authorization system\n     *\n     *  usage - used as a rule in cases of receiving data\n     *          before going to the page, all data is\n     *          requested in parallel, combining such images\n     *\n     *          loader. displaying errors,\n     *          receiving data, checking for a logged in user\n     *\n     *  @param resolverCallback { function }\n     *  @param customFunctions {{\n     *      resolverSecondWorker: undefined | function,\n     *      resolveFirstWorkerError: undefined | function,\n     *      beforeIntercept: undefined | function,\n     *      afterIntercept: undefined | function,\n     *      resolveSecondWorkerError: undefined | function\n     *  }} check resolver methods, its the same but for custom usage, not for global\n     *\n     *  @return { Function | Promise }\n     */\n\n    routeInterceptor(\n        resolverCallback,\n        customFunctions\n    ) {\n\n        customFunctions = isObject(\n            customFunctions,\n            {}\n        );\n\n        const {\n            resolverSecondWorker,\n            resolveFirstWorkerError,\n            beforeIntercept,\n            afterIntercept,\n            resolveSecondWorkerError\n        } = customFunctions;\n\n        return async (to, from, next) => {\n\n            const standardDataParams = {\n                to,\n                from\n            };\n\n            const standardDataParamsWithNext = {\n                ...standardDataParams,\n                next\n            };\n\n            isFunction(\n                beforeIntercept,\n                this[METHOD_HOOK_ENUM.BEFORE_INTERCEPT]\n            )(standardDataParams);\n\n            const resultAsyncCheck = await this[\n                METHOD_HOOK_ENUM.RESOLVER_FIRST_WORKER\n            ](standardDataParamsWithNext);\n\n            if (typeof resultAsyncCheck !== JS_TYPES_ENUM.BOOLEAN || !resultAsyncCheck) {\n                const firstWorkerError = {\n                    ...standardDataParamsWithNext,\n                    error: 'FIRST_WORKER_ERROR'\n                };\n\n                isFunction(\n                    resolveFirstWorkerError,\n                    this[METHOD_HOOK_ENUM.RESOLVER_FIRST_WORKER_ERROR]\n                )(firstWorkerError);\n\n                return next(false)\n            }\n\n            if (typeof resolverCallback === JS_TYPES_ENUM.FUNCTION) {\n                try {\n                    let objRequests = resolverCallback(to, from);\n\n\n                    objRequests = isObject(\n                        objRequests,\n                        {}\n                    );\n\n                    const result = await (\n                        isFunction(\n                            resolverSecondWorker,\n                            this[METHOD_HOOK_ENUM.RESOLVER_SECOND_WORKER]\n                        )(objRequests)\n                    );\n\n                    Object\n                        .keys(result)\n                        .forEach((item) => to.meta[ item ] = result[ item ]);\n\n                } catch ( error ) {\n\n                    const paramsWithError = {\n                        ...standardDataParams,\n                        error\n                    };\n\n                    isFunction(\n                        resolveSecondWorkerError,\n                        this[METHOD_HOOK_ENUM.RESOLVER_SECOND_WORKER_ERROR]\n                    )(paramsWithError);\n\n                    return next(false);\n                }\n            }\n\n            isFunction(\n                afterIntercept,\n                this[METHOD_HOOK_ENUM.AFTER_INTERCEPT]\n            )(standardDataParamsWithNext);\n\n            return next(true);\n        }\n    }\n\n    /**\n     *  _defaultSecondWorker\n     *\n     *  definition - and gets a function object, where each\n     *               function returns a promise, done in order to\n     *               make parallel requests and return a response object\n     *\n     *  usage - check definition\n     *\n     *  @param objRequests\n     *  @return {Promise<void>}\n     *  @private\n     */\n\n    async _defaultSecondWorker (objRequests) {\n        const objData = {};\n        const arrayRequests = Object\n            .keys(objRequests)\n            .map((key, index) => {\n                objData[ index ] = key;\n                return typeof objRequests[ key ] === JS_TYPES_ENUM.FUNCTION\n                    ? objRequests[ key ]()\n                    : Promise.resolve(null);\n            });\n\n        let result = [];\n\n        result = await Promise.all(arrayRequests);\n\n        Object\n            .keys(objData)\n            .forEach(i => {\n                objData[ objData[ i ] ] = result[ i ];\n                delete objData[ i ];\n            });\n\n        return objData;\n    }\n\n    /**\n     *\n     *  registerBeforeIntercept\n     *\n     *  definition - function registration\n     *\n     *  @param fn\n     *  @return {*}\n     */\n\n    registerBeforeIntercept(fn) {\n        return this.registerMethod(\n            METHOD_HOOK_ENUM.BEFORE_INTERCEPT,\n            fn\n        );\n    }\n\n    /**\n     *  registerAfterIntercept\n     *\n     *  definition - function registration\n     *\n     *  @param fn\n     *  @return {*}\n     */\n\n    registerAfterIntercept(fn) {\n        return this.registerMethod(\n            METHOD_HOOK_ENUM.AFTER_INTERCEPT,\n            fn\n        );\n    }\n\n    /**\n     *\n     *  registerResolverFirstWorker\n     *\n     *  definition - function registration\n     *\n     *  @param fn\n     *  @return {*}\n     */\n\n    registerResolverFirstWorker(fn) {\n        return this.registerMethod(\n            METHOD_HOOK_ENUM.RESOLVER_FIRST_WORKER,\n            fn\n        );\n    }\n\n    /**\n     *\n     *  registerResolverSecondWorker\n     *\n     *  definition - function registration\n     *\n     *  @param fn\n     *  @return {*}\n     */\n\n    registerResolverSecondWorker(fn) {\n        return this.registerMethod(\n            METHOD_HOOK_ENUM.RESOLVER_SECOND_WORKER,\n            fn\n        );\n    }\n\n\n    /**\n     *\n     *  registerResolverFirstWorkerError\n     *\n     *  definition - function registration\n     *\n     *  @param fn\n     *  @return {*}\n     */\n\n    registerResolverFirstWorkerError(fn) {\n        return this.registerMethod(\n            METHOD_HOOK_ENUM.RESOLVER_FIRST_WORKER_ERROR,\n            fn\n        );\n    }\n\n\n    /**\n     *\n     *  registerResolverSecondWorkerError\n     *\n     *  definition - function registration\n     *\n     *  @param fn\n     *  @return {*}\n     */\n\n    registerResolverSecondWorkerError(fn) {\n        return this.registerMethod(\n            METHOD_HOOK_ENUM.RESOLVER_SECOND_WORKER_ERROR,\n            fn\n        );\n    }\n\n    /**\n     *  registerMethod\n     *\n     *  definition - reusable function, which takes the name of\n     *               the method and the callback, thereby reassigning\n     *               the default execution\n     *\n     *  usage - used to register different methods\n     *\n     *  @param name\n     *  @param callBack\n     *  @return {VueResolver}\n     */\n\n    registerMethod(name, callBack) {\n        if (typeof callBack !== JS_TYPES_ENUM.FUNCTION || !name) {\n            return this;\n        }\n\n        this[name] = callBack;\n\n        return this;\n    }\n}\n"],"names":["METHOD_HOOK_ENUM","JS_TYPES_ENUM","checkIfExistType","varA","varB","type","_typeof","isObject","isFunction","VueResolver","_classCallCheck","this","_defineProperty","ret","Promise","resolve","_defFunction","_defFunctionPromise","_defaultSecondWorker","_defaultSecondWorker2","key","value","resolverCallback","customFunctions","_this","_customFunctions","resolverSecondWorker","resolveFirstWorkerError","beforeIntercept","afterIntercept","resolveSecondWorkerError","_ref","_asyncToGenerator","regeneratorRuntime","mark","to","from","next","standardDataParams","standardDataParamsWithNext","resultAsyncCheck","firstWorkerError","objRequests","result","paramsWithError","wrap","_context","prev","sent","error","Object","keys","forEach","item","meta","t0","stop","_callee","_x","_x2","_x3","apply","arguments","objData","arrayRequests","_context2","map","index","all","i","abrupt","_callee2","_x4","fn","registerMethod","name","callBack"],"mappings":"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"}